package org.occurrent.eventstore.jpa;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.persistence.EntityManagerFactory;
import javax.sql.DataSource;

import lombok.val;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtendWith;
import org.occurrent.condition.Condition;
import org.occurrent.eventstore.jpa.batteries.CloudEventDao;
import org.occurrent.eventstore.jpa.batteries.CloudEventDaoLog;
import org.occurrent.eventstore.jpa.batteries.CloudEventDaoLogOperations;
import org.occurrent.eventstore.jpa.batteries.StreamEventDaoConverter;
import org.occurrent.eventstore.jpa.utils.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@ContextConfiguration(
    classes = {JpaBlockingEventStorePostgresTest.PGConfig.class, RepositoryConfig.class})
@ExtendWith(SpringExtension.class)
@Testcontainers
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class JpaBlockingEventStorePostgresTest
    extends JpaBlockingEventStoreTestBase<CloudEventDao, JPAEventStore<Long, CloudEventDao>> {
  static final String USER_NAME = "user";
  static final String PASSWORD = "password";
  static final String DB = "db";

  @Container
  static final PostgreSQLContainer<?> postgres =
      new PostgreSQLContainer<>("postgres:15-alpine")
          .withUsername(USER_NAME)
          .withPassword(PASSWORD)
          .withDatabaseName(DB);

  @TestConfiguration
  static class PGConfig {
    @Bean("dataSource")
    DataSource dataSource() {
      postgres.start();
      return DataSourceBuilder.create()
          .driverClassName("org.postgresql.Driver")
          .url(
              String.format(
                  "jdbc:postgresql://%s:%s/%s?stringtype=unspecified",
                  postgres.getHost(), postgres.getFirstMappedPort(), DB))
          .username(USER_NAME)
          .password(PASSWORD)
          .build();
    }
  }

  @Autowired EntityManagerFactory emf;
  @Autowired CloudEventDaoLog log;

  @Override
  JPAEventStore<Long, CloudEventDao> getNewEventStore() {
    return JPAEventStore.<Long, CloudEventDao>builder()
        .eventLog(log)
        .eventLogOperations(new PostgresOperations())
        .converter(new StreamEventDaoConverter(new ObjectMapper()))
        .build();
  }

  private void execute(String... sqls) {
    val em = emf.createEntityManager();
    em.getTransaction().begin();

    for (val sql : sqls) {
      em.createNativeQuery(sql).executeUpdate();
    }
    em.getTransaction().commit();
    em.close();
  }

  @BeforeEach
  void truncate() {
    val truncateSQL = "TRUNCATE TABLE \"public\".\"cloud_events\";";
    execute(truncateSQL);
  }

  @BeforeAll
  void create_table() {
    // https://medium.com/dandelion-tutorials/using-spring-data-jpa-for-integration-tests-without-spring-boot-starter-9f87877d098f

    // JPA creates the table wrong. Drop it and create it correctly.
    val dropSql = "DROP TABLE IF EXISTS \"public\".\"cloud_events\";";

    val sql =
        """
          CREATE TABLE "public"."cloud_events" (
              "id" BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
              "stream_revision" BIGINT NOT NULL,
              "stream_id" TEXT NOT NULL,
              "event_id" text NOT NULL UNIQUE,
              "source" TEXT NOT NULL,
              "type" TEXT NOT NULL,
              "timestamp" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
              "subject" text,
              "data_content_type" text,
              "data" jsonb,
              "data_schema" text,
              "spec_version" text,
              CONSTRAINT "cloud-events-pk" PRIMARY KEY ("id")
          );
          """;

    execute(dropSql, sql);
  }

  static class PostgresOperations extends CloudEventDaoLogOperations {
    @Override
    public <U> Specification<CloudEventDao> bySingleCondition(
        String fieldName, Condition.SingleOperandCondition<U> fieldCondition) {
      if (null == fieldName) {
        return super.bySingleCondition(null, fieldCondition);
      }
      if (!fieldName.contains("data")) {
        return super.bySingleCondition(fieldName, fieldCondition);
      }

      val parts = fieldName.split("\\.");
      if (parts.length != 2) {
        throw new UnsupportedOperationException("Unexpected query dsl expression. Cannot query nested data fields");
      }

      val jsonField = parts[1];

      U expectedVersion = fieldCondition.operand();

      // https://stackoverflow.com/a/48492202
      // https://medium.com/@bayern01kahn/spring-data-jpa-examples-querying-data-by-json-properties-in-postgressql-e88dd9eabee9
      return (root, query, cb) -> {
        return cb.equal(
            cb.function(
                "jsonb_extract_path_text", String.class, root.get("data"), cb.literal(jsonField)),
            expectedVersion);
      };
    }
  }
}
